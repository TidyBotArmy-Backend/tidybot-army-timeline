# Fetch commits from org repos and update timeline
name: Fetch Org Commits

on:
  # Run every hour
  schedule:
    - cron: '0 * * * *'
  # Allow manual trigger with options
  workflow_dispatch:
    inputs:
      commits_per_repo:
        description: 'Number of commits to fetch per repo'
        required: false
        default: '5'
      skip_time_filter:
        description: 'Fetch recent commits regardless of time'
        required: false
        type: boolean
        default: true

permissions:
  contents: write

jobs:
  fetch-commits:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch org commits and update entries
        uses: actions/github-script@v7
        env:
          ORG_NAME: ${{ github.repository_owner }}
          COMMITS_PER_REPO: ${{ github.event.inputs.commits_per_repo || '5' }}
          SKIP_TIME_FILTER: ${{ github.event.inputs.skip_time_filter || 'false' }}
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const fs = require('fs');
            const org = process.env.ORG_NAME;
            const commitsPerRepo = parseInt(process.env.COMMITS_PER_REPO) || 5;
            const skipTimeFilter = process.env.SKIP_TIME_FILTER === 'true';

            console.log(`Fetching ${commitsPerRepo} commits per repo, skip time filter: ${skipTimeFilter}`);

            // Read existing entries
            let entries = [];
            try {
              const data = fs.readFileSync('logs/entries.json', 'utf8');
              entries = JSON.parse(data);
            } catch (e) {
              console.log('No existing entries, starting fresh');
            }

            // Get existing timestamps to avoid duplicates
            const existingTimestamps = new Set(entries.map(e => e.timestamp + e.title));

            // Fetch repos in the org
            const repos = await github.paginate(github.rest.repos.listForOrg, {
              org: org,
              type: 'all',
              per_page: 100
            });

            console.log(`Found ${repos.length} repos in ${org}`);

            // Fetch recent commits from each repo
            const since = skipTimeFilter ? undefined : new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();

            // Get this repo's name to exclude it
            const thisRepo = process.env.GITHUB_REPOSITORY.split('/')[1];
            console.log(`Skipping commits from: ${thisRepo}`);

            for (const repo of repos) {
              // Skip this timeline repo
              if (repo.name === thisRepo) continue;

              try {
                const params = {
                  owner: org,
                  repo: repo.name,
                  per_page: commitsPerRepo
                };
                if (since) params.since = since;

                const commits = await github.rest.repos.listCommits(params);

                for (const commit of commits.data) {
                  const date = new Date(commit.commit.author.date);
                  const timestamp = date.toISOString().slice(0, 16).replace('T', ' ');
                  const message = commit.commit.message.split('\n')[0]; // First line only

                  // Determine type from commit message
                  let type = 'feature';
                  const msgLower = message.toLowerCase();
                  if (msgLower.startsWith('fix') || msgLower.includes('bug')) type = 'fix';
                  else if (msgLower.startsWith('refactor')) type = 'refactor';
                  else if (msgLower.startsWith('test') || msgLower.includes('test')) type = 'test';
                  else if (msgLower.startsWith('doc') || msgLower.includes('readme')) type = 'docs';
                  else if (msgLower.includes('deploy') || msgLower.includes('release')) type = 'deploy';
                  else if (msgLower.includes('setup') || msgLower.includes('init') || msgLower.includes('config')) type = 'setup';

                  const key = timestamp + message;
                  if (!existingTimestamps.has(key)) {
                    entries.push({
                      timestamp: timestamp,
                      type: type,
                      title: message.slice(0, 80),
                      description: `Commit by ${commit.commit.author.name} in ${repo.name}`,
                      files: [`${repo.name}/`],
                      sha: commit.sha.slice(0, 7),
                      repo: repo.name,
                      author: commit.commit.author.name
                    });
                    existingTimestamps.add(key);
                    console.log(`Added: ${message.slice(0, 50)}...`);
                  }
                }
              } catch (e) {
                console.log(`Error fetching commits for ${repo.name}: ${e.message}`);
              }
            }

            // Sort by timestamp (newest last)
            entries.sort((a, b) => a.timestamp.localeCompare(b.timestamp));

            // Keep last 200 entries max
            if (entries.length > 200) {
              entries = entries.slice(-200);
            }

            // Write back
            fs.writeFileSync('logs/entries.json', JSON.stringify(entries, null, 2));
            console.log(`Total entries: ${entries.length}`);

      - name: Commit and push if changed
        id: commit
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add logs/entries.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Update timeline entries"
            git remote set-url origin https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}.git
            git push
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Trigger page rebuild
        if: steps.commit.outputs.changed == 'true'
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          curl -X POST \
            -H "Authorization: token ${PAT_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d '{"event_type":"update-timeline"}'
