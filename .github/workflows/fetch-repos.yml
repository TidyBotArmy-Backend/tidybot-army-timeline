# Fetch repos from skills and services orgs
name: Fetch Repos

on:
  # Run every 15 minutes
  schedule:
    - cron: '*/15 * * * *'
  # Allow manual trigger
  workflow_dispatch:
  # Triggered by org webhooks on new repo creation
  repository_dispatch:
    types: [new-repo]

permissions:
  contents: write

jobs:
  fetch-skills:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch skill repos
        uses: actions/github-script@v7
        env:
          ORG_NAME: tidybot-skills
        with:
          github-token: ${{ secrets.PAT_TOKEN_FRONTEND }}
          script: |
            const fs = require('fs');
            const org = process.env.ORG_NAME;

            console.log(`Fetching repos from ${org}...`);

            const repos = await github.paginate(github.rest.repos.listForOrg, {
              org: org,
              type: 'all',
              per_page: 100
            });

            console.log(`Found ${repos.length} repos in ${org}`);

            // Filter out infra repos
            const ignoredRepos = ['wishlist', 'TestRepo', '.github'];
            const filteredRepos = repos.filter(r => !ignoredRepos.includes(r.name));
            console.log(`${filteredRepos.length} repos after filtering`);

            // Fetch catalog.json from wishlist repo for skill metadata
            let catalog = {};
            try {
              const { data } = await github.rest.repos.getContent({
                owner: org,
                repo: 'wishlist',
                path: 'catalog.json'
              });
              const content = Buffer.from(data.content, 'base64').toString('utf8');
              const parsed = JSON.parse(content);
              catalog = parsed.skills || {};
              console.log(`Loaded catalog.json with ${Object.keys(catalog).length} skills`);
            } catch (e) {
              console.log(`Failed to fetch catalog.json: ${e.message}`);
            }

            // Fetch deps.txt from a skill repo (single source of truth for dependencies)
            async function getDependencies(org, repoName, branch) {
              try {
                const { data } = await github.rest.repos.getContent({
                  owner: org, repo: repoName, path: 'deps.txt', ref: branch
                });
                return Buffer.from(data.content, 'base64').toString('utf8')
                  .trim().split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));
              } catch (e) {
                return [];
              }
            }

            // Fetch services.txt from a skill repo (external service dependencies)
            async function getServiceDeps(org, repoName, branch) {
              try {
                const { data } = await github.rest.repos.getContent({
                  owner: org, repo: repoName, path: 'services.txt', ref: branch
                });
                return Buffer.from(data.content, 'base64').toString('utf8')
                  .trim().split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));
              } catch (e) {
                return [];
              }
            }

            // Fetch sdk.txt from a skill repo (robot_sdk function usage)
            async function getSdkFunctions(org, repoName, branch) {
              try {
                const { data } = await github.rest.repos.getContent({
                  owner: org, repo: repoName, path: 'sdk.txt', ref: branch
                });
                return Buffer.from(data.content, 'base64').toString('utf8')
                  .trim().split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));
              } catch (e) {
                return [];
              }
            }

            // Discover trial images from each repo's trials/ directory
            async function getTrialImages(org, repoName, branch) {
              try {
                const { data: contents } = await github.rest.repos.getContent({
                  owner: org,
                  repo: repoName,
                  path: 'trials',
                  ref: branch
                });
                if (!Array.isArray(contents)) return [];
                return contents
                  .filter(f => /\.(jpg|jpeg|png|gif|webp)$/i.test(f.name))
                  .sort((a, b) => a.name.localeCompare(b.name))
                  .slice(0, 10)
                  .map(f => f.download_url);
              } catch (e) {
                return [];
              }
            }

            // Map to timeline-friendly format, sorted by creation time (oldest first)
            const sorted = filteredRepos
              .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

            const entries = [];
            for (let index = 0; index < sorted.length; index++) {
              const repo = sorted[index];
              const meta = catalog[repo.name] || {};
              const trial_images = await getTrialImages(org, repo.name, repo.default_branch);
              const dependencies = await getDependencies(org, repo.name, repo.default_branch);
              const service_dependencies = await getServiceDeps(org, repo.name, repo.default_branch);
              const sdk_functions = await getSdkFunctions(org, repo.name, repo.default_branch);
              if (trial_images.length > 0) {
                console.log(`  ${repo.name}: found ${trial_images.length} trial images`);
              }
              if (dependencies.length > 0) {
                console.log(`  ${repo.name}: deps = [${dependencies.join(', ')}]`);
              }
              if (service_dependencies.length > 0) {
                console.log(`  ${repo.name}: services = [${service_dependencies.join(', ')}]`);
              }
              if (sdk_functions.length > 0) {
                console.log(`  ${repo.name}: sdk = [${sdk_functions.join(', ')}]`);
              }
              entries.push({
                id: String(index + 1).padStart(3, '0'),
                name: repo.name,
                description: repo.description || 'No description',
                created_at: repo.created_at,
                updated_at: repo.updated_at,
                html_url: repo.html_url,
                language: repo.language || 'Unknown',
                stars: repo.stargazers_count,
                is_private: repo.private,
                default_branch: repo.default_branch,
                success_rate: meta.success_rate ?? 0,
                total_trials: meta.total_trials ?? 0,
                institutions_tested: meta.institutions_tested ?? 0,
                trial_images: trial_images,
                dependencies: dependencies,
                service_dependencies: service_dependencies,
                sdk_functions: sdk_functions
              });
            }

            fs.writeFileSync('logs/repos.json', JSON.stringify(entries, null, 2));
            console.log(`Wrote ${entries.length} skills to logs/repos.json`);

      - name: Commit and push if changed
        id: commit-skills
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN_FRONTEND }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add logs/repos.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Update skill repos"
            git remote set-url origin https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}.git
            git push
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

  fetch-services:
    runs-on: ubuntu-latest
    needs: fetch-skills
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Pull latest
        run: git pull origin main

      - name: Fetch service repos
        uses: actions/github-script@v7
        env:
          ORG_NAME: TidyBot-Services
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const fs = require('fs');
            const org = process.env.ORG_NAME;

            console.log(`Fetching repos from ${org}...`);

            const repos = await github.paginate(github.rest.repos.listForOrg, {
              org: org,
              type: 'all',
              per_page: 100
            });

            console.log(`Found ${repos.length} repos in ${org}`);

            // Filter out infra repos
            const ignoredRepos = ['.github', 'tidybot-templates', 'TidyBot-Services.github.io', 'Tidybot-Universe'];
            const filteredRepos = repos.filter(r => !ignoredRepos.includes(r.name));
            console.log(`${filteredRepos.length} repos after filtering`);

            // Map to timeline-friendly format, sorted by creation time (oldest first)
            const entries = filteredRepos
              .sort((a, b) => new Date(a.created_at) - new Date(b.created_at))
              .map((repo, index) => ({
                id: String(index + 1).padStart(3, '0'),
                name: repo.name,
                description: repo.description || 'No description',
                created_at: repo.created_at,
                updated_at: repo.updated_at,
                html_url: repo.html_url,
                language: repo.language || 'Unknown',
                stars: repo.stargazers_count,
                is_private: repo.private,
                default_branch: repo.default_branch
              }));

            fs.writeFileSync('logs/services.json', JSON.stringify(entries, null, 2));
            console.log(`Wrote ${entries.length} services to logs/services.json`);

      - name: Commit and push if changed
        id: commit-services
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add logs/services.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Update service repos"
            git remote set-url origin https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}.git
            git push
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Trigger page rebuild
        if: steps.commit-services.outputs.changed == 'true'
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          curl -X POST \
            -H "Authorization: token ${PAT_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d '{"event_type":"update-timeline"}'
